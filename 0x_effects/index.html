<!DOCTYPE html>
<html>

<head>
    <title>Learn you shaders</title>

    <link rel="stylesheet" href="../css/style.css" />
    <link rel="stylesheet" href="../lib/codemirror.css">
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />

    <script src="../lib/p5.min.js"></script>
    <script src="../lib/codemirror.js"></script>
    <script src="../mode/markdown/js.js"></script>
    <script src="../lib/jquery-3.2.1.min.js"></script>
</head>

<body>
    <header>
        <h1 class="title">Learn you Shaders</h1>
        <h1>Tunnel Viz</h1>
    </header>
    <hr/>
    <div id="content">

        <img src='img/hero.png' class='hero'>
        <p>
            One of the first times I came across this tunnel effect demo was on ShaderToy. I was immediately captivated by terse code. In about 5 lines of code, a beautiful and convincing visualization emerges--it seemed magical.
        </p>
        <p>
            I was motivated to understand exactly how it worked. I studied the code--dismantling and putting it back together. It took me quite a while, but I'd like to share what I have learned. Hopefully this tutorial will be of use to you.
        </p>
        <p>
            We're going to build up the shader piecemeal. Each time a new concept is introduced, the code in the shader will be highlighted.
        </p>
 
        <!-- ************* -->
        <h2>Step X: Empty Canvas</h2>
        <p>
            Let's start by filling the canvas with a solid color. Oh boy, so much excitement.
        </p>
        <textarea class='glsl-code' data-params='{"width":400,"height":200}' data-example='code/0.glsl'></textarea>


        <!-- ************* -->
        <!--         <hr/>
        <h2>Step 2: The Coordinate System</h2>
        <img src='img/empty_graph.png' class='hero'>
        <p>
        </p>
 -->


        <!-- ************* -->
        <hr/>
        <h2>Step X: Texture</h2>
        <p>
            Let's map a texture onto the canvas.
        </p>
        <textarea class='glsl-code' data-params='{"width":400,"height":200,"tex0":"tex/debug.png","lines":[4,5,6]}' data-example='code/texture.glsl'></textarea>

        <p>
            We need 2 uniforms: a texture unit and a resolution.
        </p>
        <p>
            The <em>texture2D</em> function expects a texture and a vec2 with normalized components. For the coordinates, we'll take the current pixel location and divide by the resolution.
            <code>
                [x] 0..400 => 0..1<br />
                [y] 0..200 => 0..1
            </code>
        </p>
        <p>
        <!--
            We need the resolution because we need to create a vector with normalized components.

            Each fragment will be the result of sampling the texture.
            the bottom left corner is 0,0. The top-right corner will be 1,1.
        -->
        </p>
        <p>
            Our canvas is rectangular but the texture we're using is a square, so warping will occur. You'll notice the texture is also upside down! What the shit? Well, that just won't do...
        </p>
        <p>
            Note how we're using GLSL's syntactic sugar to perform component-wise division. If you are feeling verbose, you can write the division thus:
            <br />
            <textarea class='glsl-snippet'>vec2 uv = vec2(gl_FragCoord.x / u_res.x, gl_FragCoord.y / u_res.y);</textarea>
        </p>

        <div class='advanced'>
            <img src="../public/icons/advanced.png" class="icon" />
            <span>Texture repeating</span>
            <br />
            <p>
                Wait a second! Doesn't texture2D do texture repeating? Can't we pass in non-normalized values? Yes. OpenGL and WebGL have a function we can call to set the texture repetition parameter (repeat,stretch,etc.). Try multiplying the uv.x component by something greater than 1. What happens?
            </p>
            <p>
                We're going to pretend that texture2D expects normalized values, so we'll just take care of 'wrapping' the values ourselves.
            </p>
        </div>



        <!-- ************* -->
        <hr/>
        <h2>Step X: Texture Flip</h2>
        <p>
            WebGL has this weird behaviour where textures are flipped. We can actually solve this by getting the rendered from p5 and calling a function that tells WebGL if we want textures fippped.
        </p>
        <p>
            But since we have power of shaders, we can do the flip within the shader itself. Since we know that the maximum value of y is 1, we start with 1 and subtract whatever the y value is. This remaps the y-coordinates from 0..1 to 1..0.
        </p>
        <textarea class='glsl-code' data-params='{"width":400,"height":200,"tex0":"tex/debug.png","lines":[11]}' data-example='code/flip_y.glsl'></textarea>




        <!-- ************* -->
        <hr/>
        <h2>Step X: Repeating the Texture</h2>
        <p>
            Examine the final demo and you can see that the texture is repeated. We can easily achieve this by using the built-in mod function. Not surprisingly, mod accepts 2 values.
        </p>
        <p>
            we scale the x component by 4 then modulus it, thus ensuring the value ranges for 0 to 1.
        </p>
        <textarea class='glsl-code' data-params='{"width":400,"height":200,"tex0":"tex/debug.png","lines":[12]}' data-example='code/repeat_tex.glsl'></textarea>




        <!-- ************* -->
        <hr/>
        <h2>Step X: Perspective</h2>
        <p>
            The core 'magic' of the tunnel is the perspective that gets created. How is this done? We need to somehow repeat the texture more frequently the closer it is to the center of the canvas.
        </p>
        <p>
            Let's head over to Google and plug in this formula:
            <code>y = 1/x</code>
        </p>
        <img src='img/google_graph.png' class='hero'>
        <p>
            This graph show that y has a sharp decline and tends towards infinity as x increases in size.Â  However our x ranges from 0 to 1, not 0 to 26 as the table suggests.
        </p>
        <!-- <img src='img/table.png' class='hero'> -->
        <textarea class='glsl-code' data-params='{"width":400,"height":200,"tex0":"tex/debug.png"}' data-example='code/perspective.glsl'></textarea>




        <!-- ************* -->
        <hr/>
        <h2>Step X: Making it Circular</h2>
        <p>
            ....
        </p>
        <textarea class='glsl-code' data-params='{"width":400,"height":200,"tex0":"tex/debug.png"}' data-example='code/circular.glsl'></textarea>




        <!-- ************* -->
        <hr/>
        <h2>Step X: Fog</h2>
        <p>
            The center of the demo has this mushyness. Let's fix that. And the solution is pretty simple. We're just going to cover it up :)
        </p>
        <textarea class='glsl-code' data-params='{"width":400,"height":200,"tex0":"tex/debug.png"}' data-example='code/fog.glsl'></textarea>




        <!-- ************* -->
        <hr>
        <h2>Step X: Texture</h2>
        <p>
            Finally, we're going to replace the debug image to the actual texture.
        </p>
        <textarea class='glsl-code' data-params='{"width":400,"height":200,"tex0":"tex/tex.jpg"}' data-example='code/final.glsl'></textarea>




        <!-- ************* -->
        <hr>
        <h2>Step X: Adding Movement</h2>
        <p>
            Let's make it seem like the user is moving through the tunnel.
        </p>
        <textarea class='glsl-code' data-params='{"width":400,"height":200,"loop":"true","tex0":"tex/tex.jpg"}' data-example='code/movement.glsl'></textarea>




        <!-- ************* -->
        <h2>Step X: Adding Interactivity</h2>
        <p>
            What we have is great, but let's go one step further.
        </p>
        <textarea class='glsl-code' data-params='{"width":400,"height":200,"loop":"true","tex0":"tex/tex.jpg"}' data-example='code/interactivity.glsl'></textarea>




        <!-- ********* -->
        <hr/>
        <h2>Play time!</h2>
        <p>
            <ul class="exercises">
                <li>Add a bump map texture</li>
            </ul>
        </p>
    </div>




    <!-- ********* -->
    <hr/>
    <footer>
        <ul class="nav">
            <li><a onclick="goPrev();">&lt; Prev</a></li>
            <li><a onclick="goHome();">Home</a></li>
            <li><a onclick="goNext();">Next &gt;</a></li>
        </ul>
    </footer>

    <script src="/js/init-cm.js"></script>

</body>

</html>